<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*jslint todo: true, browser: true, continue: true, white: true*/
/*global earcut*/

/**
 * Written by Alex Canales for ShopBotTools, Inc.
 */

/**
 * Namespace for the API. All function and class definitions lie in this
 * namespace or its children namespaces.
 *
 * @namespace
 */
var api = {};

/**
 * Constant for converting inches values into millimeters values. Used by
 * convertInchToMillimeter.
 */
api.INCH_TO_MILLIMETER = 25.4;

/**
 * Constant for converting millimeters values into inches values. Used by
 * convertMillimeterToInch.
 */
api.MILLIMETER_TO_INCH = 0.03937008;

/**
 * Converts an unit in inches to an unit in millimeters.
 *
 * @param {number} unit - The unit in inches.
 * @return {number} The unit in millimeters.
 */
api.convertInchToMillimeter = function(unit) {
    return unit * api.INCH_TO_MILLIMETER;
};

/**
 * Converts an unit in millimeters to an unit in inches.
 *
 * @param {number} unit - The unit in millimeters.
 * @return {number} The unit in inches.
 */
api.convertMillimeterToInch = function(unit) {
    return unit * api.MILLIMETER_TO_INCH;
};

/********************************* Math part **********************************/

/**
 * This part defines functions for math functionalities.
 * @namespace
 */
api.math = {};

api.math.FLOAT_PRECISION = 0.001;

/**
 * Checks if two numbers are nearly equal. This function is used to avoid
 * to have too much precision when checking values between floating-point
 * numbers.
 *
 * @param {number} a - Number A.
 * @param {number} b - Number B.
 * @param {number} [precision=api.math.FLOAT_PRECISION] - The precision of the
 * comparison.
 * @return {boolean} True if the two values are nearly equal.
 */
api.math.nearlyEqual = function(a, b, precision) {
    "use strict";
    var p = (precision === undefined) ? api.math.FLOAT_PRECISION : precision;
    return Math.abs(b - a) &lt;= p;
};

/**
 * Creates a vector. Vectors are used to store simple points too.
 *
 * @class
 * @param {number} [x=0] - The x position.
 * @param {number} [y=0] - The y position.
 * @param {number} [z=0] - The z position.
 * @return {Vector} A vector.
 */
api.math.Vector = function(x, y, z) {
    "use strict";
    this.x = (x === undefined) ? 0 : x;
    this.y = (y === undefined) ? 0 : y;
    this.z = (z === undefined) ? 0 : z;
};

api.math.Vector.prototype = {

    /**
     * Clones the vector.
     *
     * @return {Vector} A new vector.
     */
    clone : function() {
        "use strict";
        return new api.math.Vector(this.x, this.y, this.z);
    },

    /**
     * Checks if two vectors are equal (i.e at the same position).
     *
     * @param {Vector} vector - The other vector.
     * @param {number} [precision=api.math.FLOAT_PRECISION] - The precision of
     * the comparison.
     * @return {boolean} True if the two vectors are equal.
     */
    equal: function(vector, precision) {
        "use strict";
        var p = (precision === undefined) ? api.math.FLOAT_PRECISION : precision;
        return (api.math.nearlyEqual(this.x, vector.x, p) &amp;&amp;
            api.math.nearlyEqual(this.y, vector.y, p) &amp;&amp;
            api.math.nearlyEqual(this.z, vector.z, p));

    },

    /**
     * Returns the squared length of the vector.
     *
     * @return {number}  The squared length.
     */
    lengthSquared : function() {
        "use strict";
        return this.x * this.x + this.y * this.y + this.z * this.z;
    },

    /**
     * Returns the length of the vector.
     *
     * @return {number}  The length.
     */
    length : function() {
        "use strict";
        return Math.sqrt(this.lengthSquared());
    },

    /**
     * Returns the normalized vector (without changing the vector).
     *
     * @return {Vector} The normalized vector.
     */
    normalizedVector : function() {
        "use strict";
        var l = this.length();
        if(l === 0) {
            return this.clone();
        }

        return new api.math.Vector(this.x / l, this.y / l, this.z / l);
    }
};

/**
 * Returns the scalar product of two vectors.
 *
 * @param {Vector} vectorA - Vector A.
 * @param {Vector} vectorB - Vector B.
 * @return {number} The scalar product.
 */
api.math.Vector.scalar = function(vectorA, vectorB) {
    "use strict";
    return (vectorA.x * vectorB.x +
            vectorA.y * vectorB.y +
            vectorA.z * vectorB.z);
};

/**
 * Returns the cross product of two vectors.
 *
 * @param {Vector} vectorA - Vector A.
 * @param {Vector} vectorB - Vector B.
 * @return {Vector} The cross product.
 */
api.math.Vector.cross = function(vectorA, vectorB) {
    "use strict";
    var x = vectorA.y * vectorB.z - vectorA.z * vectorB.y;
    var y = vectorA.z * vectorB.x - vectorA.x * vectorB.z;
    var z = vectorA.x * vectorB.y - vectorA.y * vectorB.x;
    return new api.math.Vector(x, y, z);
};

/**
 * Creates a vector going from point A to point B.
 * @param {Vector} pointA - Point A.
 * @param {Vector} pointB - Point B.
 * @return {Vector} A new vector going from point A to point B.
 */
api.math.Vector.fromPoints = function(pointA, pointB) {
    "use strict";
    return new api.math.Vector(
        pointB.x - pointA.x,
        pointB.y - pointA.y,
        pointB.z - pointA.z
    );
};

/**
 * Returns a new point which is the result of a rotation of the point according
 * to the center, the angle and scale.
 *
 * @param {Vector} point - The original point to transform. Not modified.
 * @param {Vector} center - The center of rotation and scale.
 * @param {number} angle - The angle in degree.
 * @param {number} scale - The scale of the transformation.
 * @return {Vector} The result of the transformation.
 */
api.math.rotation2D = function(point, center, angle, scale) {
    "use strict";
    // newPoint = scale * point * exp(i angle) + center
    var angleRad = angle * Math.PI / 180;
    var cosAngle = Math.cos(angleRad);
    var sinAngle = Math.sin(angleRad);
    var vector = new api.math.Vector.fromPoints(center, point);
    var newPoint = new api.math.Vector(center.x, center.y, 0);
    newPoint.x += scale * (vector.x * cosAngle - vector.y * sinAngle);
    newPoint.y += scale * (vector.x * sinAngle + vector.y * cosAngle);
    return newPoint;
};

/**
 * Returns the barycenter of the polygon defined by an array of points. Points
 * are considered 2D and having a weight of 1.
 *
 * @param {Vector[]) points - The array of points defining the polygon.
 * @return {Vector|boolean} The barycenter of the polygon. Returns false if the
 * array is empty.
 */
api.math.barycenter2D = function(points) {
    "use strict";
    var numberPoints = points.length;
    var sumX = 0;
    var sumY = 0;
    var i = 0;

    if(numberPoints === 0) {
        return false;
    }

    for(i = 0; i &lt; numberPoints; i++) {
        sumX += points[i].x;
        sumY += points[i].y;
    }

    return new api.math.Vector(sumX / numberPoints, sumY / numberPoints, 0);
};

/**
 * Returns the sign of the angle defined by the vectors center to pointA and
 * center to pointB.
 *
 * @param {Vector} center - The center of the angle.
 * @param {Vector} pointA - Point A.
 * @param {Vector} pointB - Point B.
 * @return {boolean} True if the sign is positive or zero, else false.
 * */
api.math.angleSignPoints = function(center, pointA, pointB) {
    "use strict";
    var u = api.math.Vector.fromPoints(center, pointA);
    var v = api.math.Vector.fromPoints(center, pointB);
    var cross = api.math.Vector.cross(u, v);
    return (cross.z >= 0);
};

/**
 * Checks if the polygon defined by the array of points is convex. Points
 * are considered 2D.
 *
 * @param {Vector[]) points - The array of points defining the polygon.
 * @return {boolean} True if the polygon is convex.
 */
api.math.isConvexPolygon = function(polygon) {
    "use strict";
    var numberPoints = polygon.length;
    if(numberPoints &lt;= 2) {
        return false;
    }
    if(numberPoints === 3) {
        return true;
    }

    var completePolygon = polygon.slice();
    completePolygon.push(completePolygon[0]);

    var referenceAngleSign = api.math.angleSignPoints(
        completePolygon[0],
        completePolygon[numberPoints - 1],
        completePolygon[1]
    );
    var angleSign;
    var i;

    for(i=1; i &lt; numberPoints; i++) {
        angleSign = api.math.angleSignPoints(
            completePolygon[i],
            completePolygon[i - 1],
            completePolygon[i + 1]
        );
        if(angleSign !== referenceAngleSign) {
            return false;
        }
    }

    return true;
};

/******************************* Cut properties *******************************/

/**
 * Creates the cut properties.
 *
 * @class
 * @param {number} [bitWidth=0] - Bit width in inches.
 * @param {number} [bitLength=0] - Bit length in inches.
 * @param {number} [stepover=0] - The stepover ratio.
 * @param {number} [feedrate=0] - The feed rate in inches per minutes.
 * @return {CutProperties} The cut properties.
 */
api.CutProperties = function(bitWidth, bitLength, stepover, feedrate) {
    "use strict";
    this.bitLength = (bitLength === undefined) ? 0 : bitLength;
    this.bitWidth = (bitWidth === undefined) ? 0 : bitWidth;
    this.stepover = (stepover === undefined) ? 0 : stepover;
    this.feedrate = (feedrate === undefined) ? 0 : feedrate;
};

/******************************* Tab properties *******************************/

/**
 * Creates the tab properties. It is considered as not used if the width or the
 * height is equal or below to zero.
 *
 * @class
 * @param {number} [width=0] - Width in inches.
 * @param {number} [length=0] - Length in inches.
 * @return {TabProperties} The tab properties.
 */
api.TabProperties = function(width, height) {
    "use strict";
    this.width = (width === undefined) ? 0 : width;
    this.height = (height === undefined) ? 0 : height;
};

api.TabProperties.prototype = {
    /**
     * The maximum angle a tab can have when cutting a circle.
     */
    MAX_ANGLE : 45,

    /**
     * If the tab are correct and can be used.
     *
     * @return {boolean} True if the tab can be used.
     */
    isUsed : function() {
        "use strict";
        return (this.width > 0 &amp;&amp; this.height > 0);
    }
};

/******************************** G-Code part *********************************/

/**
 * This part defines functions for generating GCode.
 * When a function has a problem, returns false else the GCode.
 *
 * We consider a three axis tool with Z as the height and depth.
 * The coordinates are absolute.
 * @namespace
 */
api.gcode = (function() {

    /**
     * Returns the 2D points path for the cut. If the length is equal to 2, there
     * is notabs to do else the length is 4 and the tabs are defined in the points
     * at index 1 and 2.
     *
     * @param {Vector} start - The starting point (considered 2D).
     * @param {Vector} end - The ending point (considered 2D).
     * @param {TabProperties} The tab properties.
     * @return {Vector[]} The 2D points path for the cut.
     */
    function pointsAccordingToTabs(start, end, tabProperties) {
        "use strict";
        //We are not using the Z value:
        var start2D = new api.math.Vector(start.x, start.y, 0);
        var end2D = new api.math.Vector(end.x, end.y, 0);
        var points = [start2D, end2D];

        if(tabProperties.isUsed() === false) {
            return points;
        }

        //Tabs bigger than the actual cut path
        var vector = api.math.Vector.fromPoints(start2D, end2D);
        if(vector.lengthSquared() &lt;= (tabProperties.width * tabProperties.width)) {
            return points;
        }

        //Create the intermediate points
        var normalized = vector.normalizedVector();
        var distanceStartTab = (vector.length() - tabProperties.width) / 2;
        var pointA = start2D.clone();
        pointA.x += normalized.x * distanceStartTab;
        pointA.y += normalized.y * distanceStartTab;
        var pointB = pointA.clone();
        pointB.x += normalized.x * tabProperties.width;
        pointB.y += normalized.y * tabProperties.width;

        points.splice(1, 0, pointA, pointB);
        return points;
    }

    return {

        /**
         * Generates G-Code for moving as fast as possible the bit to the point
         * (G0).  Never use this function for cutting through material.
         *
         * @memberof api.gcode
         * @param {Vector} point - The point to reach.
         * @return {string} The generated G-Code.
         */
        jogTo : function(point) {
            "use strict";
            var code = "G0";
            if(point.x !== undefined) {
                code += " X" + point.x.toFixed(5);
            }
            if(point.y !== undefined) {
                code += " Y" + point.y.toFixed(5);
            }
            if(point.z !== undefined) {
                code += " Z" + point.z.toFixed(5);
            }
            return code;
        },

        /**
         * Generates G-Code for moving the bit to the point (G1). This is the
         * function to use when cutting through material.
         *
         * @memberof api.gcode
         * @param {Vector} point - The point to reach.
         * @param {number} feedrate - The feed rate in inches per minutes.
         * @return {string|boolean} The generated G-Code or false if impossible
         * to parse the given polygon.
         */
        moveTo : function(point, feedrate) {
            "use strict";
            var code = "G1";

            if(feedrate === undefined) {
                return false;
            }

            if(point.x !== undefined) {
                code += " X" + point.x.toFixed(5);
            }
            if(point.y !== undefined) {
                code += " Y" + point.y.toFixed(5);
            }
            if(point.z !== undefined) {
                code += " Z" + point.z.toFixed(5);
            }
            code += " F" + feedrate.toFixed(5);

            return code;
        },

        /**
         * Generates G-Code for letting a comment in the code (in parenthesis).
         *
         * @memberof api.gcode
         * @param {string} message - The comment.
         * @return {string} The generated G-Code.
         */
        comment : function(message) {
            "use strict";
            return "(" + message + ")\n";  // Put \n in case people put G-Code after that
        },

        /**
         * Sets the plane in which the G2/G3 arcs are drawn on XY (G17). Does
         * not change the fact that functions for cutting and pocketting the
         * circles use XY plane. You should not use this function and built-in
         * functions for circle operation at the same time.
         *
         * @memberof api.gcode
         * @return {string} The generated G-Code.
         */
        selectXYPlane : function() {
            return "G17";
        },

        /**
         * Sets the plane in which the G2/G3 arcs are drawn on XZ (G18). Does
         * not change the fact that functions for cutting and pocketting the
         * circles use XY plane. You should not use this function and built-in
         * functions for circle operation at the same time.
         *
         * @memberof api.gcode
         * @return {string} The generated G-Code.
         */
        selectXZPlane : function() {
            return "G18";
        },

        /**
         * Sets the plane in which the G2/G3 arcs are drawn on YZ (G19). Does
         * not change the fact that functions for cutting and pocketting the
         * circles use XY plane. You should not use this function and built-in
         * functions for circle operation at the same time.
         *
         * @memberof api.gcode
         * @return {string} The generated G-Code.
         */
        selectYZPlane : function() {
            return "G19";
        },

        /**
         * Generates G-Code for setting the values in the code in inches (G20).
         * Does not change the fact that the values used by the functions in
         * this API are in inches.
         *
         * @memberof api.gcode
         * @return {string} The generated G-Code.
         */
        inInches : function() {
            return "G20";
        },

        /**
         * Generates G-Code for setting the values in the code in millimeters
         * (G21).  Does not change the fact that the values used by the
         * functions in this API are in inches.
         *
         * @memberof api.gcode
         * @return {string} The generated G-Code.
         */
        inMillimeters : function() {
            return "G21";
        },

        /**
         * Generates G-Code for ending the program (M2).
         *
         * @memberof api.gcode
         * @return {string} The generated G-Code.
         */
        end : function() {
            return "M2";
        },

        /**
         * Generates G-Code for turning on the spindle (M4).
         *
         * @memberof api.gcode
         * @param {number} [speed] - The speed
         * @return {string} The generated G-Code.
         */
        spindleOn : function(speed) {
            if(speed !== undefined) {
                return "M4 S" + speed;
            }
            return "M4";
        },

        /**
         * Generates G-Code for turning off the spindle (M5).
         *
         * @memberof api.gcode
         * @return {string} The generated G-Code.
         */
        spindleOff : function() {
            return "M5";
        },

        /**
         * Generates G-Code for ending the program and returning to its start
         * (M30).
         *
         * @memberof api.gcode
         * @return {string} The generated G-Code.
         */
        rewind : function() {
            return "M30";
        },

        /**
         * Generates G-Code for stopping the program (M60).
         *
         * @memberof api.gcode
         * @return {string} The generated G-Code.
         */
        stop : function() {
            return "M60";
        },

        /**
         * Generates G-Code for cutting the path. The bit will simply go from a
         * point to another. This function is used to have better performance
         * than using consecutively the moveTo function.
         *
         * @memberof api.gcode
         * @param {Vector[]} path - The path points.
         * @param {number} feedrate - The feed rate in inches per minutes.
         * @param {number} [safeZ] - The safe Z position to go after the cut.
         * @return {string} The generated G-Code.
         */
        cutPath : function(path, feedrate, safeZ) {
            "use strict";
            if(path.length === 0) {
                return "";
            }

            var code = [];
            var i = 0;
            var feedrateString = " F" + feedrate.toFixed(5);

            for(i=0; i &lt; path.length; i++) {
                code.push(
                    "G1 X" + path[i].x.toFixed(5) +
                    " Y" + path[i].y.toFixed(5) +
                    " Z" + path[i].z.toFixed(5) +
                    feedrateString
                );
            }

            if(safeZ !== undefined) {
                code.push("G1 Z" + safeZ.toFixed(5) + feedrateString);
            }

            return code.join("\n");
        },

        /**
         * Generates G-Code for cutting the path and letting tabs for each
         * straight lines (if possible). The path is considered 2D on the XY
         * plane.
         *
         * @memberof api.gcode
         * @param {Vector[]} path2D - The path.
         * @param {number} depth - The depth in inches.
         * @param {CutProperties} cutProperties - The cut properties.
         * @param {TabProperties} tabProperties - The tabs properties.
         * @param {number} [safeZ] - The safe Z position to go after the cut in
         * inches.
         * @return {string|boolean} The generated G-Code or false if impossible
         * to parse the given path.
         */
        cutPath2DWithTabs : function(
            path2D, depth, cutProperties, tabProperties, safeZ
        ) {
            "use strict";
            if(path2D.length &lt; 2) {
                return false;
            }

            function getPaths2DWithTabs(path, tabProperties) {
                var i = 0;
                var straightWithTabs = [];
                var pathsWithTabs = [];
                for(i=0; i &lt; path.length - 1; i++) {
                    straightWithTabs = pointsAccordingToTabs(
                        path[i],
                        path[i+1],
                        tabProperties
                    );
                    pathsWithTabs.push(straightWithTabs);
                }
                return pathsWithTabs;
            }

            var Paths2DWithTabsController = function(paths2DWithTabs) {
                this.hasToReverse = true;
                this.normal = paths2DWithTabs;
                this.reversed = [];
                this.setReversedPath();
            };

            Paths2DWithTabsController.prototype = {
                setReversedPath : function() {
                    var i = 0, j = 0;
                    var straight = [];
                    this.resersed  = [];
                    for(i = this.normal.length-1; i >= 0; i--) {
                        straight = [];
                        for(j = this.normal[i].length - 1; j >= 0; j--) {
                            straight.push(this.normal[i][j].clone());
                        }
                        this.reversed.push(straight);
                    }
                },

                // The first time is called, it throws the normal path
                // Returns path to use and swipe for the next time it is asked
                getCurrentPaths : function() {
                    this.hasToReverse = (this.hasToReverse === false);
                    if(this.hasToReverse === true) {
                        return this.reversed;
                    }
                    return this.normal;
                }
            };

            function getPath3DFromStraightPath2D(straight, currentZ, tabZ, useTabs) {
                var point;
                var path3D = [];
                if(useTabs === true &amp;&amp; straight.length === 4 &amp;&amp; currentZ &lt; tabZ) {
                    point = straight[0];
                    path3D.push((new api.math.Vector(point.x, point.y, currentZ)));

                    point = straight[1];
                    path3D.push(new api.math.Vector(point.x, point.y, currentZ));
                    path3D.push(new api.math.Vector(point.x, point.y, tabZ));

                    point = straight[2];
                    path3D.push(new api.math.Vector(point.x, point.y, tabZ));
                    path3D.push(new api.math.Vector(point.x, point.y, currentZ));

                    point = straight[3];
                    path3D.push(new api.math.Vector(point.x, point.y, currentZ));
                } else {
                    point = straight[0];
                    path3D.push(new api.math.Vector(point.x, point.y, currentZ));
                    point = straight[straight.length - 1];
                    path3D.push(new api.math.Vector(point.x, point.y, currentZ));
                }
                return path3D;
            }

            var path3D = [];
            var currentPaths2D = [];
            var finalZ = -depth;
            var currentZ = 0;
            var tabZ = tabProperties.height - depth;
            var controller = new Paths2DWithTabsController(
                getPaths2DWithTabs(path2D, tabProperties)
            );
            var point = controller.normal[0][0];
            var i = 0;

            path3D.push(new api.math.Vector(point.x, point.y, safeZ));
            while(currentZ > finalZ) {
                currentZ = Math.max(currentZ - cutProperties.bitLength, finalZ);
                currentPaths2D = controller.getCurrentPaths();

                for(i=0; i &lt; currentPaths2D.length; i++) {
                    path3D = path3D.concat(
                        getPath3DFromStraightPath2D(
                            currentPaths2D[i], currentZ, tabZ, tabProperties.isUsed()
                        )
                    );
                }
            }

            return this.cutPath(path3D, cutProperties.feedrate, safeZ);
        },

        /**
         * Generates G-Code for cutting the patth. The path is considered 2D on
         * the XY plane. It is assumed that the bit is above the board.
         *
         * @memberof api.gcode
         * @param {Vector[]} path2D - The path with absolute coordinates in
         * inches.
         * @param {number} depth - The depth in inches.
         * @param {CutProperties} cutProperties - The cut properties.
         * @param {number} [safeZ] - The safe Z position to go after the cut in
         * inches.
         * @return {string|boolean} The generated G-Code or false if impossible
         * to parse the given path.
         */
        cutPath2D : function(path, depth, cutProperties, safeZ) {
            "use strict";
            if(path.length &lt; 2) {
                return false;
            }

            var t = new api.TabProperties();
            return this.cutPath2DWithTabs(path, depth, cutProperties, t, safeZ);
        },

        /**
         * Generates G-Code for cutting the polygon and letting tabs. The order
         * of the polygon tips is important. The bit will go to a point to the
         * next one and close the polygon by going from the last point to the
         * first point. The polygon is considered 2D on the XY plane. Use this
         * function if you cut completely through the material. It is assumed
         * that the bit is above the board.
         *
         * @memberof api.gcode
         * @param {Vector[]} polygon - The polygon tip points with absolute
         * coordinates in inches.
         * @param {number} depth - The depth in inches.
         * @param {CutProperties} cutProperties - The cut properties.
         * @param {TabProperties} tabProperties - The tabs properties.
         * @param {number} [safeZ] - The safe Z position to go after the cut in
         * inches.
         * @return {string|boolean} The generated G-Code or false if impossible
         * to parse the given polygon.
         */
        cutPolygonWithTabs : function(
            polygon, depth, cutProperties, tabProperties, safeZ
        ) {
            "use strict";
            if(polygon.length &lt; 3) {
                return false;
            }


            // Cannot use cutPath2DWithTabs, it has a different behaviour
            var completePolygon = polygon.slice();
            completePolygon.push(completePolygon[0]);
            var pathsWithTabs = [];
            var straightWithTabs = [];
            var point;
            var path = [];
            var finalZ = -depth;
            var currentZ = 0;
            var tabZ = tabProperties.height - depth;
            var i = 0;

            if(tabProperties.isUsed() === true) {
                for(i=0; i &lt; completePolygon.length - 1; i++) {
                    straightWithTabs = pointsAccordingToTabs(
                        completePolygon[i],
                        completePolygon[i+1],
                        tabProperties
                    );
                    pathsWithTabs.push(straightWithTabs);
                }
            }

            point = completePolygon[0];
            path.push(new api.math.Vector(point.x, point.y, safeZ));

            currentZ = 0;
            finalZ = -depth;
            while(currentZ > finalZ) {
                currentZ = Math.max(currentZ - cutProperties.bitLength, finalZ);

                if(tabProperties.isUsed() === true &amp;&amp; currentZ &lt; tabZ) {
                    if(pathsWithTabs.length > 0 &amp;&amp; pathsWithTabs[0].length > 0) {
                        point = pathsWithTabs[0][0];
                        path.push(new api.math.Vector(point.x, point.y, currentZ));
                    }
                    for(i=0; i &lt; pathsWithTabs.length; i++) {
                        // Not pushing first one to avoid duplicate G-Code
                        point = pathsWithTabs[i][1];
                        path.push(new api.math.Vector(point.x, point.y, currentZ));

                        // Here a path length is equal to 2 (no tabs) or 4 (with tabs)
                        if(pathsWithTabs[i].length === 4) {
                            path.push(new api.math.Vector(point.x, point.y, tabZ));

                            point = pathsWithTabs[i][2];
                            path.push(new api.math.Vector(point.x, point.y, tabZ));
                            path.push(new api.math.Vector(point.x, point.y, currentZ));

                            point = pathsWithTabs[i][3];
                            path.push(new api.math.Vector(point.x, point.y, currentZ));
                        }
                    }
                } else {
                    for(i=0; i &lt; completePolygon.length; i++) {
                        point = completePolygon[i];
                        path.push(new api.math.Vector(point.x, point.y, currentZ));
                    }
                }
            }

            return this.cutPath(path, cutProperties.feedrate, safeZ);
        },

        /**
         * Generates G-Code for cutting the polygon. The order of the polygon
         * tips is important. The bit will go to a point to the next one and
         * close the polygon by going from the last point to the first point.
         * The polygon is considered 2D on the XY plane. Do not use this
         * function if you cut completely through the material: you need tabs
         * for that. Without tabs, the cutting part can be thrown because of
         * the spindle rotation. It is assumed that the bit is above the board.
         *
         * @memberof api.gcode
         * @param {Vector[]} polygon - The polygon tip points with absolute
         * coordinates in inches.
         * @param {number} depth - The depth in inches.
         * @param {CutProperties} cutProperties - The cut properties.
         * @param {number} [safeZ] - The safe Z position to go after the cut in
         * inches.
         * @return {string|boolean} The generated G-Code or false if impossible
         * to parse the given polygon.
         */
        cutPolygon : function(polygon, depth, cutProperties, safeZ) {
            "use strict";
            if(polygon.length &lt; 3) {
                return false;
            }

            var t = new api.TabProperties();
            return this.cutPolygonWithTabs(polygon, depth, cutProperties, t, safeZ);
        },

        /**
         * Generates G-Code for pocketing the convex polygon. The order of the
         * polygon tips is important. The bit will go to a point to the next
         * one and close the polygon by going from the last point to the first
         * point. The polygon is considered 2D on the XY plane. If the polygon
         * is not convex, the behaviour is undefined. It is assumed that the
         * bit is above the board.
         *
         * @memberof api.gcode
         * @param {Vector[]} polygon - The polygon tip points with absolute
         * coordinates in inches.
         * @param {number} depth - The depth in inches.
         * @param {CutProperties} cutProperties - The cut properties.
         * @param {number} [safeZ] - The safe Z position to go after the cut in
         * inches.
         * @return {string|boolean} The generated G-Code or false if impossible
         * to parse the given polygon.
         */
        pocketConvexPolygon : function(polygon, depth, cutProperties, safeZ) {
            "use strict";
            if(polygon.length &lt; 3) {
                return false;
            }

            var completePolygon = polygon.slice();
            completePolygon.push(completePolygon[0]);
            var deltaMove = cutProperties.stepover * cutProperties.bitWidth;
            var center = api.math.barycenter2D(polygon);
            var numberPoints = polygon.length;
            var i = 0;
            var vector;
            var vectors = [];
            var deltaPath = [];
            var numberIteration = 0;
            var path = [];
            var currentZ = 0;
            var finalZ = -depth;
            var n = 0;
            var biggestLength = 0;

            for(i = 0; i &lt; numberPoints; i++) {
                vector = new api.math.Vector(
                    center.x - polygon[i].x,
                    center.y - polygon[i].y,
                    0
                );
                biggestLength = Math.max(vector.lengthSquared(), biggestLength);
                vectors.push(vector);
            }
            vectors.push(vectors[0]);  //To follow completePolygon
            numberIteration = biggestLength / deltaMove;

            if(numberIteration === 0) {
                return false;
            }

            for(i = 0; i &lt; numberPoints; i++) {
                deltaPath.push(new api.math.Vector(
                        vectors[i].x / numberIteration,
                        vectors[i].y / numberIteration,
                        0
                ));
            }
            deltaPath.push(deltaPath[0]);  //To follow completePolygon

            path.push(new api.math.Vector(polygon[0].x, polygon[0].y, safeZ));
            currentZ = 0;
            finalZ = -depth;
            while(currentZ > finalZ) {
                currentZ = Math.max(currentZ - cutProperties.bitLength, finalZ);

                //Starting by numberIteration to cut inside-out
                for(n = numberIteration; n >= 0; n--) {
                    for(i=0; i &lt; numberPoints + 1; i++) {
                        path.push(new api.math.Vector(
                                completePolygon[i].x + n * deltaPath[i].x,
                                completePolygon[i].y + n * deltaPath[i].y,
                                currentZ
                        ));
                    }
                }
            }

            return this.cutPath(path, cutProperties.feedrate, safeZ);
        },

        /**
         * Generates G-Code for pocketing the polygon. The order of the polygon
         * tips is important. The bit will go to a point to the next one and
         * close the polygon by going from the last point to the first point.
         * The polygon is considered 2D on the XY plane. It is assumed that the
         * bit is above the board.
         *
         * @memberof api.gcode
         * @requires earcut.js
         * @param {Vector[]} polygon - The polygon tip points with absolute
         * coordinates in inches.
         * @param {number} depth - The depth in inches.
         * @param {CutProperties} cutProperties - The cut properties.
         * @param {number} [safeZ] - The safe Z position to go after the cut in
         * inches.
         * @return {string} The generated G-Code.
         */
        pocketSimplePolygon : function(polygon, depth, cutProperties, safeZ) {
            "use strict";

            function convertVertexToPoint(earcutPolygon, vertexIndex) {
                var xIndex = vertexIndex * 2;  // 2 because 2D
                return new api.math.Vector(
                    earcutPolygon[xIndex],
                    earcutPolygon[xIndex + 1],
                    0
                );
            }

            function convertTriangleVertexIndicesToTriangle(
                earcutPolygon, a, b, c
            ) {
                var triangle = [];
                triangle.push(convertVertexToPoint(earcutPolygon, a));
                triangle.push(convertVertexToPoint(earcutPolygon, b));
                triangle.push(convertVertexToPoint(earcutPolygon, c));
                return triangle;
            }

            function triangulatePolygon(polygon) {
                var triangles = [];
                var earcutPolygon = [];
                var i = 0;
                for(i = 0; i &lt; polygon.length; i++) {
                    earcutPolygon.push(polygon[i].x);
                    earcutPolygon.push(polygon[i].y);
                }

                var trianglesVertices = earcut(earcutPolygon);

                for(i = 0; i &lt; trianglesVertices.length; i += 3) {
                    triangles.push(
                        convertTriangleVertexIndicesToTriangle(
                            earcutPolygon,
                            trianglesVertices[i],
                            trianglesVertices[i + 1],
                            trianglesVertices[i + 2]
                        )
                    );
                }

                return triangles;
            }

            var triangles = triangulatePolygon(polygon);
            var trianglesCode = [];
            var i = 0;

            for(i = 0; i &lt; triangles.length; i++) {
                trianglesCode.push(
                    this.pocketConvexPolygon(
                        triangles[i], depth, cutProperties, safeZ
                    )
                );
            }

            return trianglesCode.join("\n");
        },

        /**
         * Generates G-Code for cutting the circle and letting tabs. The circle
         * is considered 2D on the XY plane. Use this function if you cut
         * completely. It is assumed that the bit is above the board.
         * through the material.
         *
         * @memberof api.gcode
         * @param {Vector} center - The circle center with absolute coordinates
         * in inches.
         * @param {number} radius - The radius in inches.
         * @param {number} depth - The depth in inches.
         * @param {CutProperties} cutProperties - The cut properties.
         * @param {TabProperties} tabProperties - The tabs properties.
         * @param {number} [safeZ] - The safe Z position to go after the cut in
         * inches.
         * @return {string|boolean} The generated G-Code or false if impossible
         * to parse the given polygon.
         */
        cutCircleWithTabs : function(
            center, radius, depth, cutProperties, tabProperties, safeZ
        ) {
            "use strict";
            if(radius === 0) {
                return false;
            }

            var start = new api.math.Vector(center.x + radius, center.y, 0);
            var feedrateString = " F" + cutProperties.feedrate.toFixed(5);
            var useTabs = tabProperties.isUsed();
            var codeTabs = [];
            var code = [];
            var str = "";
            var tabAngle = 0;
            var normalAngle = 0;
            var end;
            var finalZ = -depth;
            var currentZ = 0;
            var tabZ = tabProperties.height - depth;

            var codeWithoutTab = "G3 X" + start.x.toFixed(5);
            codeWithoutTab += " Y" +start.y.toFixed(5);
            codeWithoutTab += " I" + (-radius).toFixed(5) + feedrateString;

            if(useTabs === true) {
                //perimeter = 2*pi*r; ratio = tabWidth / perimeter;
                //tabAngle = 360 * ratio;
                tabAngle = (180 * tabProperties.width) / (Math.PI * radius);
                if(tabAngle >= tabProperties.MAX_ANGLE) {
                    console.log("Tab angle = " + tabAngle);
                    useTabs = false;
                } else {
                    normalAngle = 180 - tabAngle;

                    end = api.math.rotation2D(start, center, normalAngle, 1);
                    str = "G3 X" + end.x.toFixed(5) + " Y" + end.y.toFixed(5);
                    str += " R" + radius.toFixed(5) + feedrateString;
                    codeTabs.push(str);

                    end = api.math.rotation2D(end, center, tabAngle, 1);
                    str = "G3 X" + end.x.toFixed(5) + " Y" + end.y.toFixed(5);
                    str += " R" + radius.toFixed(5) + feedrateString;
                    codeTabs.push(str);

                    end = api.math.rotation2D(end, center, normalAngle, 1);
                    str = "G3 X" + end.x.toFixed(5) + " Y" + end.y.toFixed(5);
                    str += " R" + radius.toFixed(5) + feedrateString;
                    codeTabs.push(str);

                    //To make sure we close the circle, we go to start:
                    str = "G3 X" + start.x.toFixed(5) + " Y" + start.y.toFixed(5);
                    str += " R" + radius.toFixed(5) + feedrateString;
                    codeTabs.push(str);
                }
            }

            str = "G1 X" + start.x.toFixed(5) + " Y" + start.y.toFixed(5);
            str += feedrateString;
            code.push(str);
            code.push(this.selectXYPlane());

            finalZ = -depth;
            currentZ = 0;
            while(currentZ > finalZ) {
                currentZ = Math.max(currentZ - cutProperties.bitLength, finalZ);
                code.push("G1 Z" + currentZ.toFixed(5) + feedrateString);

                if(useTabs === true &amp;&amp; currentZ &lt; tabZ) {
                    code.push(codeTabs[0]);
                    code.push("G1 Z" + tabZ.toFixed(5) + feedrateString);
                    code.push(codeTabs[1]);
                    code.push("G1 Z" + currentZ.toFixed(5) + feedrateString);
                    code.push(codeTabs[2]);
                    code.push("G1 Z" + tabZ.toFixed(5) + feedrateString);
                    code.push(codeTabs[3]);
                } else {
                    code.push(codeWithoutTab);
                }
            }

            if(safeZ !== undefined) {
                code.push("G1 Z" + safeZ.toFixed(5) + feedrateString);
            }

            return code.join("\n");
        },

        /**
         * Generates G-Code for cutting a circle. The circle is considered 2D
         * on the XY plane. Do not use this function if you cut completely
         * through the material: you need tabs for that. Without tabs, the
         * cutting part can be thrown because of the spindle rotation. It is
         * assumed that the bit is above the board.
         *
         * @memberof api.gcode
         * @param {Vector} center - The circle center with absolute coordinates
         * in inches.
         * @param {number} radius - The radius in inches.
         * @param {number} depth - The depth in inches.
         * @param {CutProperties} cutProperties - The cut properties.
         * @param {number} [safeZ] - The safe Z position to go after the cut in
         * inches.
         * @return {string|boolean} The generated G-Code or false if impossible
         * to parse the given polygon.
         */
        cutCircle : function(center, radius, depth, cutProperties, safeZ) {
            "use strict";
            var t = new api.TabProperties();
            return this.cutCircleWithTabs(
                center, radius, depth, cutProperties, t, safeZ
            );
        },

        /**
         * Generates G-Code for pocketing a circle. The circle is considered 2D
         * on the XY plane. It is assumed that the bit is above the board.
         *
         * @memberof api.gcode
         * @param {Vector} center - The circle center with absolute coordinates
         * in inches.
         * @param {number} radius - The radius in inches.
         * @param {number} depth - The depth in inches.
         * @param {CutProperties} cutProperties - The cut properties.
         * @param {number} [safeZ] - The safe Z position to go after the cut in
         * inches.
         * @return {string|boolean} The generated G-Code or false if impossible
         * to parse the given polygon.
         */
        pocketCircle : function(center, radius, depth, cutProperties, safeZ) {
            "use strict";
            if(cutProperties.bitWidth > radius * 2) {
                return false;
            }

            var deltaMove = cutProperties.stepover * cutProperties.bitWidth;
            var newX = 0;
            var deltaRadius = 0;
            var code = [];
            var feedrateString = " F" + cutProperties.feedrate.toFixed(5);
            var currentZ = 0;
            var finalZ = -depth;
            var codeGoCenter = "G1 X" + center.x.toFixed(5);
            codeGoCenter += " Y" + center.y.toFixed(5) + feedrateString;

            code.push(this.selectXYPlane());

            while(currentZ > finalZ) {
                currentZ = Math.max(currentZ - cutProperties.bitLength, finalZ);
                //From inside to outside
                code.push(codeGoCenter);
                code.push("G1 Z" + currentZ.toFixed(5) + feedrateString);
                while(deltaRadius &lt; radius) {
                    deltaRadius = Math.min(deltaRadius + deltaMove, radius);
                    newX = center.x + deltaRadius;
                    code.push("G1 X" + newX.toFixed(5) + feedrateString);
                    code.push("G2 X" + newX.toFixed(5) + " I " + (-deltaRadius).toFixed(5) + feedrateString);
                }
            }

            if(safeZ !== undefined) {
                code.push("G1 Z" + safeZ.toFixed(5) + feedrateString);
            }

            return code.join("\n");
        }
    };
}());
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="api.CutProperties.html">CutProperties</a></li><li><a href="api.math.Vector.html">Vector</a></li><li><a href="api.TabProperties.html">TabProperties</a></li></ul><h3>Namespaces</h3><ul><li><a href="api.html">api</a></li><li><a href="api.gcode.html">gcode</a></li><li><a href="api.math.html">math</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Aug 15 2016 16:23:48 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
